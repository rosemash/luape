/*
see python/hack.py for the steps that make this program work
without being modified, the executable generated by this program will crash
*/

#include <stdint.h>
#include <string.h>
#include <libloaderapi.h> //for GetModuleHandleA

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// luasocket
#ifdef LUASOCKET_C
#include <mime.h>
#include <luasocket.h>
#endif

volatile const uint32_t MAGIC_OFFSET = 0x13371337; // this is a placeholder, it should be be updated after compilation to point to the script

int main(int argc, char* argv[]) {

	// create the lua state for the script, include standard library
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);

#ifdef LUASOCKET_C
	// make luasocket core functions requireable with package.preload
	lua_getfield(L, LUA_GLOBALSINDEX, "package");
	lua_getfield(L, -1, "preload");
	lua_pushcfunction(L, luaopen_socket_core);
	lua_setfield(L, -2, "socket.core");
	lua_pushcfunction(L, luaopen_mime_core);
	lua_setfield(L, -2, "mime.core");
	lua_pop(L, 2);
#endif

	// pass C command line arguments onto the lua script (as global "arg")
	lua_createtable(L, argc, 0);
	for (int i = 0; i < argc; i++)
	{
		lua_pushstring(L, argv[i]);
		lua_rawseti(L, -2, i);
	}
	lua_setglobal(L, "arg");

	// attempt to load the lua script, wherever it may be
	void* magicPointer = (void*)((uint32_t)GetModuleHandleA(NULL) + MAGIC_OFFSET);
	uint32_t size = *(uint32_t*)(magicPointer);
	const char* source = (const char*)(magicPointer + 0x4);
	luaL_loadbuffer(L, source, size, "=lua");

	// basic execute + error handling
	if (lua_type(L, -1) == LUA_TFUNCTION)
	{
		lua_pcall(L, 0, 0, 0);
		if (lua_gettop(L) > 0)
		{
			printf("%s\n", lua_tostring(L, -1));
		}
	}
	else
	{
		// this happens a lot when something goes wrong, so hope you don't see this error
		printf("failed to load chunk: %s\n", lua_tostring(L, -1));
	}

	lua_close(L);

	return 0;
}
