if #arg < 2 then
	print(("%s <source OR file:source.lua> <output.exe> [option...]"):format(_FILENAME:match("^.+[/\\](.+)$") or _FILENAME))
	return
end

local flags = table.concat(arg, " ", 3)

local function hasFlag(name)
	return flags:match("[/-]+" .. name) ~= nil
end

local subsystemMode = 0x3
if hasFlag("hidden") then
	print("output exectuable will in gui subsystem (no console)")
	subsystemMode = 0x2
end

local buff = ""

local function encodeNumber(num, size)
	local encoded = ""
	for i = 1, size do
		encoded = encoded .. string.char(num % 0x100)
		num = num / 0x100
	end
	return encoded
end

local function seekAndPatch(file, offset, num, size)
	buff = buff .. file:read(offset - file:seek())
	local existingVal = 0
	for c in file:read(size):reverse():gmatch(".") do existingVal = existingVal * 0x100 + c:byte() end
	buff = buff .. encodeNumber(num, size)
	if num ~= existingVal then
		print(("0x%.8x %db %d->%d"):format(file:seek()-size, size, existingVal, num))
	end
end

local source = arg[1]
local filename = source:match("^file:(.+)$")
if filename then
	local input = io.open(filename, "r")
	source = input:read("*all")
	input:close()
end

local func, errmsg = loadstring(source, "=lua")
if not func then
	print("error compiling lua source: " .. errmsg)
	return
end
source = string.dump(func)
source = encodeNumber(#source, 4) .. source

local self = io.open(_FILENAME, "rb")
seekAndPatch(self, {isizeoffs:d}, {imagesize:d} + #source, 4)
seekAndPatch(self, {smodeoffs:d}, subsystemMode, 2)
seekAndPatch(self, {vsizeoffs:d}, #source, 4)
seekAndPatch(self, {rsizeoffs:d}, #source, 4)
buff = buff .. self:read({luastart:d} - self:seek()) .. source
self:close()

local output = io.open(arg[2], "wb")
output:write(buff)
output:write(("\0"):rep({alignment:d})) --to compensate for file alignment
output:close()

print(("Wrote %d bytes to %q."):format(#buff, arg[2]))
